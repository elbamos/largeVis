#include "neighbors.h"

int getNumThreads() {
	char const* num_threads = std::getenv("RCPP_PARALLEL_NUM_THREADS");
	if (num_threads == NULL) return -1;
	if (strcmp(num_threads, "") == 0) return -1;
	else return atoi(num_threads);
}

using namespace arma;

template<class M, typename distancemetric, typename Distance>
void trees(
		LVAnnoyIndex<distancemetric, Distance>& annoy_index,
		const M& data,
		const unsigned int& n_trees,
		const Rcpp::Nullable< Rcpp::String > &savefile,
		Progress& p
) {
	if (savefile.isNotNull()) {
		String save_file_path = String(savefile);
		std::string file_path = save_file_path.get_cstring();
		annoy_index.on_disk_build(file_path.c_str(), NULL);
	}
	vector<distancemetric> tmp(data.n_rows);
	for (size_t i = 0; i < data.n_cols; ++i) {
		copy(data.col(i).begin(), data.col(i).end(), tmp.begin());
		annoy_index.add_item(i, tmp.data());
	}
	p.increment(data.n_rows * n_trees);
	int threads = getNumThreads();
	annoy_index.build(n_trees, threads);
	p.increment(data.n_rows * n_trees);
}

template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::advanceHeap(MinIndexedPQ& positionHeap,
                                    vector< Position>& positionVector) const {
	dimidxtype whichColumn = positionHeap.minIndex();
	Position& iterators = positionVector[whichColumn];
	vertexidxtype adv = iterators.advance();
	if (adv == -1) positionHeap.pop();
	else positionHeap.rotate(adv);
}

template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::addHeap(vector< std::pair<distancemetric, vertexidxtype> >& heap,
              									const vertexidxtype& i, const vertexidxtype& j) const {
		const distancemetric d = annoy_index->get_distance(i, j);
		heap.emplace_back(d, j);
		push_heap(heap.begin(), heap.end(), std::less<std::pair<distancemetric, vertexidxtype>>());
		if (heap.size() > K) {
			pop_heap(heap.begin(), heap.end(), std::less<std::pair<distancemetric, vertexidxtype>>());
			heap.pop_back();
		}
	}

template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::addToNeighborhood(const vertexidxtype& i, const vertexidxtype& j,
									                        vector< std::pair<distancemetric, vertexidxtype> >& neighborhood) const {
		const distancemetric d = annoy_index->get_distance(i, j);
		neighborhood.emplace_back(d, j);
		push_heap(neighborhood.begin(), neighborhood.end(), std::less<std::pair<distancemetric, vertexidxtype>>());
		if (neighborhood.size() > K) {
			pop_heap(neighborhood.begin(), neighborhood.end(), std::less<std::pair<distancemetric, vertexidxtype>>());
			neighborhood.pop_back();
		}
	}


template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::reduceOne(const vertexidxtype& i) {
	vector<vertexidxtype> neighbor_index;
	annoy_index->get_nns_by_item(i, K + 1, -1, &neighbor_index, NULL);

	sort(neighbor_index.begin(), neighbor_index.end());

	auto it = knns.begin_col(i);
	for (auto neigh = neighbor_index.begin(); neigh != neighbor_index.end(); ++neigh) {
		if (*neigh != i) *(it++) = *neigh;
	}

	for (; it != knns.end_col(i); ++it) *it = -1;
}

	/*
	* After the annoy-tree phase, each point has a neighborhood of candidate points
	* generated by each tree.  This function finds the K-shortest-distance points
	* for each point, and copies them into the knns matrix, sorted by index.
	*/
template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::reduce() {
	knns = imat(K,N);

	ReduceWorker<distancemetric, Distance> worker(this);
	parallelFor(0, N, worker);
}


/*
 * Given a neighborhood for a point (which may include an index for the point as well), use a
 * constant size heap to find the K nearest neighbors of the point.
 */
template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::exploreOne( const vertexidxtype& i,
									                 const imat& old_knns,
									                 vector< std::pair<distancemetric, vertexidxtype> >& nodeHeap,
									                 MinIndexedPQ& positionHeap,
									                 vector< Position >& positionVector) {
	positionVector.clear();
	nodeHeap.clear();

	positionVector.emplace_back(old_knns, i);

	positionHeap.insert(0, old_knns(0, i));
	int posVecCnt = 1;
	auto oldEnd = old_knns.end_col(i);
	for (auto it = old_knns.begin_col(i); it != oldEnd; ++it) {
		if (*it == -1) break;
		positionVector.emplace_back(old_knns, *it);
		vertexidxtype id = * (positionVector.back().first);
		positionHeap.insert(posVecCnt++, id);
	}

	vertexidxtype lastOne = -1;
	while (! positionHeap.isEmpty()) {
		const vertexidxtype nextOne = positionHeap.minKey();

		if (nextOne != lastOne && nextOne != i) {
			addHeap(nodeHeap, i, nextOne);
			lastOne = nextOne;
		}
		advanceHeap(positionHeap, positionVector);
	}

	/*
	* Before the last iteration, we keep the matrix sorted by vertexid, which makes the merge above
	* more efficient.
	*
	* We can't use std:copy because we're copying from a vector of pairs
	*/
	auto copyContinuation = std::transform(nodeHeap.begin(), nodeHeap.end(), knns.begin_col(i),
                                        [](const std::pair<distancemetric, vertexidxtype>& input) {return input.second;});
	if (copyContinuation == knns.begin_col(i)) throw Rcpp::exception("No neighbors after exploration - this is a bug.");
	sort(knns.begin_col(i), copyContinuation);
	std::fill(copyContinuation, knns.end_col(i), -1);
}

template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::exploreNeighborhood(const unsigned int& maxIter) {
	const kidxtype K = knns.n_rows;
	imat old_knns = imat(K,N);

	for (unsigned int T = 0; T != maxIter; ++T) if (! p.check_abort()) {
		swap(knns, old_knns);
		ExploreWorker<distancemetric, Distance> worker(this, &old_knns);

		parallelFor(0, N, worker);
	}
}

/*
 * Resort the matrix so in each column the neighbors are sorted by distance
 */
template<typename distancemetric, typename Distance>
imat AnnoySearch<distancemetric, Distance>::sortAndReturn() {
	SortCopyWorker<distancemetric, Distance> worker(this);
	parallelFor(0, N, worker);
	return knns;
}

template<typename distancemetric, typename Distance>
void AnnoySearch<distancemetric, Distance>::sortCopyOne(vector< std::pair<distancemetric, vertexidxtype>>& holder,
                                   const vertexidxtype& i) {
	holder.clear();
	/*
	* Its cheaper to not maintain a heap and instead just sort because we'll never have more entries than we need.
	*/
	for (auto it = knns.begin_col(i); it != knns.end_col(i) && *it != -1; ++it) {
		const distancemetric d = annoy_index->get_distance(i, *it);
		holder.emplace_back(d, *it);
	}
	sort(holder.begin(), holder.end());
	auto copyContinuation = std::transform(holder.begin(), holder.end(), knns.begin_col(i),
                                        [](const std::pair<distancemetric, vertexidxtype>& input) {return input.second;});
	std::fill(copyContinuation, knns.end_col(i), -1);
}



// Neighbor conversion functions

vertexidxtype countSize(imat x) {
	vertexidxtype ones = 0;
	for (vertexidxtype i = 0; i < x.n_cols; ++i) {
		for (vertexidxtype j = 0; j < x.n_rows; ++j) {
			if (x(j, i) == -1) ones++;
		}
	}
	return (x.n_cols * x.n_rows) - ones;
}

void neighborsToVectors(const imat& x, vector<vertexidxtype>& is, vector<vertexidxtype>& js) {
	long cols = x.n_cols;
	long rows = x.n_rows;
	long sz = countSize(x);
	is.reserve(sz);
	js.reserve(sz);
	for (long col = 0; col < cols; ++col) {
		for (long row = 0; row < rows; ++row) {
			if (x(row, col) == -1) break;
			is.push_back(col);
			js.push_back(x(row, col));
		}
	}
}

template<typename distancemetric, typename Distance>
List buildEdgeMatrix(const imat& knns, const LVAnnoyIndex<distancemetric, Distance>& index) {
	vector<vertexidxtype> is;
	vector<vertexidxtype> js;
	vector<distancetype> xs;

	neighborsToVectors(knns, is, js);

	xs.reserve(is.size());

	for (auto it_i = is.begin(), it_j = js.begin(); it_i != is.end(); ++it_i, ++it_j) {
		xs.push_back(index.get_distance(*it_i, *it_j));
	}

	List ret = List::create(
		Named("i") = IntegerVector(is.begin(), is.end()) + 1,
		Named("j") = IntegerVector(js.begin(), js.end()) + 1,
		Named("x") = NumericVector(xs.begin(), xs.end())
	);

	ret.attr("class") = "edgematrix";
	ret.attr("dims") = IntegerVector::create(knns.n_cols, knns.n_cols);
	return ret;
}

template<class M, typename distancemetric, typename Distance>
List searchTreesTyped(
		const int& n_trees,
		const int& K,
		const int& maxIter,
		const M& data,
		const Rcpp::Nullable< Rcpp::String > &saveFile,
		bool verbose
) {
	LVAnnoyIndex<distancemetric, Distance> annoy_index(data.n_rows);
	vertexidxtype pCount = (2 * n_trees * data.n_cols) + ((3 + maxIter) * data.n_cols);
	AnnoySearch<distancemetric, Distance> searcher(&annoy_index, data.n_cols, K, verbose, maxIter, pCount);
	trees<M, distancemetric, Distance>(annoy_index, data, n_trees, saveFile, searcher.p);
	searcher.reduce();
	searcher.exploreNeighborhood(maxIter);
	imat knns = searcher.sortAndReturn();

	List edgematrix = buildEdgeMatrix<distancemetric, Distance>(knns, annoy_index);

	return List(
		List::create(Named("neighbors") = knns , Named("edgematrix") = edgematrix)
	);
}


// [[Rcpp::export]]
List searchTrees(
		const int& n_trees,
		const int& K,
		const int& maxIter,
		const arma::mat& data,
		const std::string& distMethod,
		Rcpp::Nullable< Rcpp::String > &saveFile,
		bool verbose) {

	if (distMethod.compare(string("Cosine")) == 0) {
		return searchTreesTyped<arma::mat, annoy_distance, Angular>(n_trees, K, maxIter, data, saveFile, verbose);
	} else if (distMethod.compare(string("Euclidean")) == 0) {
		return searchTreesTyped<arma::mat, annoy_distance, Euclidean>(n_trees, K, maxIter, data, saveFile, verbose);
	} else if (distMethod.compare(string("Manhattan")) == 0) {
		return searchTreesTyped<arma::mat, annoy_distance, Manhattan>(n_trees, K, maxIter, data, saveFile, verbose);
	} else {
		return searchTreesTyped<arma::mat, uint64_t, Hamming>(n_trees, K, maxIter, data, saveFile, verbose);
	}

}

List searchTreesSparse(
		const int& n_trees,
		const kidxtype& K,
		const int& maxIter,
		const sp_mat& data,
		const string& distMethod,
		const Rcpp::Nullable< Rcpp::String >& saveFile,
		bool verbose) {

	if (distMethod.compare(string("Cosine")) == 0) {
		return searchTreesTyped<sp_mat, annoy_distance, Angular>(n_trees, K, maxIter, data, saveFile, verbose);
	} else if (distMethod.compare(string("Euclidean")) == 0) {
		return searchTreesTyped<sp_mat, annoy_distance, Euclidean>(n_trees, K, maxIter, data, saveFile, verbose);
	} else if (distMethod.compare(string("Manhattan")) == 0) {
		return searchTreesTyped<sp_mat, annoy_distance, Manhattan>(n_trees, K, maxIter, data, saveFile, verbose);
	} else {
		return searchTreesTyped<sp_mat, uint64_t, Hamming>(n_trees, K, maxIter, data, saveFile, verbose);
	}
}

// [[Rcpp::export]]
List searchTreesCSparse(
		const int& n_trees,
		const int& K,
		const int& maxIter,
		const arma::uvec& i,
		const arma::uvec& p,
		const arma::vec& x,
		const std::string& distMethod,
		const Rcpp::Nullable< Rcpp::String > &saveFile,
		bool verbose) {
	const vertexidxtype N = p.size() -1;
	const sp_mat data = sp_mat(i,p,x,N,N);
	return searchTreesSparse(n_trees,K,maxIter,data,distMethod,saveFile, verbose);
}

// [[Rcpp::export]]
List searchTreesTSparse(
		const int& n_trees,
		const int& K,
		const int& maxIter,
		const arma::uvec& i,
		const arma::uvec& j,
		const arma::vec& x,
		const std::string& distMethod,
		const Rcpp::Nullable< Rcpp::String > &saveFile,
		bool verbose) {
	const umat locations = join_cols(i,j);
	const sp_mat data = sp_mat(locations,x);
	return searchTreesSparse(n_trees,K,maxIter,data,distMethod,saveFile, verbose);
}


template<typename distancemetric, typename Distance>
List denseSearchIndex(
		const int& D,
		const int& K,
		const int& maxIter,
		Rcpp::String &saveFile,
		bool verbose
) {
	LVAnnoyIndex<distancemetric, Distance> annoy_index(D);
	annoy_index.load(saveFile.get_cstring());
	vertexidxtype pCount = (3 + maxIter) * annoy_index.get_n_items();
	AnnoySearch<distancemetric, Distance> searcher(&annoy_index, annoy_index.get_n_items(), K, verbose, maxIter, pCount);
	searcher.reduce();
	searcher.exploreNeighborhood(maxIter);
	imat knns = searcher.sortAndReturn();

	List edgematrix = buildEdgeMatrix<distancemetric, Distance>(knns, annoy_index);

	return List(
		List::create(Named("neighbors") = knns , Named("edgematrix") = edgematrix)
	);
}

// [[Rcpp::export]]
List searchTreesFromIndex(
		const int& K,
		const int& D,
		const int& maxIter,
		const std::string& distMethod,
		Rcpp::String &saveFile,
		bool verbose) {

	if (distMethod.compare(string("Cosine")) == 0) {
		return denseSearchIndex<annoy_distance, Angular>(D, K, maxIter, saveFile, verbose);
	} if (distMethod.compare(string("Euclidean")) == 0) {
		return denseSearchIndex<annoy_distance, Euclidean>(D, K, maxIter, saveFile, verbose);
	} else if (distMethod.compare(string("Manhattan")) == 0) {
		return denseSearchIndex<annoy_distance, Manhattan>(D, K, maxIter, saveFile, verbose);
	} else {
		return denseSearchIndex<uint64_t, Hamming>(D, K, maxIter, saveFile, verbose);
	}
}