---
title: "ANN Benchmarks"
author: "Amos Elberg"
date: '`r Sys.Date()`'
output: github_document
---

```{r setupbenchmark,eval=T,echo=F,warning=F,error=F,message=F}
# Note to reader:  Please don't steal the semi-distinctive visual style I spent several minutes creating for myself.
library(ggplot2, 
        quietly = TRUE)
library(RColorBrewer, 
        quietly = TRUE)
library(wesanderson, 
        quietly = TRUE)
library(dplyr, quietly = TRUE)
library(magrittr, quietly = TRUE)
knitr::opts_chunk$set(collapse = TRUE, 
                      comment = "#>",
                      fig.width = 7, 
                      fig.height = 5)
colors_discrete <- function(x) rep(wes_palette("Darjeeling1", 
                                               n = min(x, 5)), 
                                   2)[1:x]
colors_divergent_discrete <- function(x) 
  grDevices::colorRampPalette(RColorBrewer::brewer.pal(x, "Spectral"))
colors_continuous <-  function(x) wes_palette(name = "Zissou",
                                              n = x, 
                                              type = "continuous")

nacol <- colors_discrete(4)[4]
theme_set(
  theme_bw() %+replace%
  theme(
    legend.title = element_text(size = rel(0.8),
                              face = "bold"),
    legend.margin = unit(0, "cm"),
    legend.position = "bottom",
    legend.key.size = unit(0.5, "lines"),
    legend.text = element_text(size = unit(8, "points")), 
    axis.title.y = element_text(angle = 90),
    axis.text = element_text(size = rel(0.7)),
    plot.margin = unit(c(0, 0.5, 1, 0), "lines"), 
    axis.title = element_text(size = rel(0.8),
                              face = "bold"),
    title = element_text(size = rel(0.9))
  ) 
)
```

## Overview

Besides manifold visualization, `largeVis` also includes an extremely efficient approximate nearest-neighbor search that runs in $O(n)$ time. 

This document includes benchmarks and recommendations for adjusting hyperparameters in the neighbor search for best results. 

## Hyperparameters

The `randomProjectionTreeSearch` function has two hyperparameters that trade-off accuracy and efficiency in the neighbor search:

1.  `n_trees` - In the first phase of the function, the number of random projection trees to create.
2.  `max_iters` - The number of iterations for the neighborhood-exploration phase of the algorithm.

## Data Collection \& Methodology

The data in the benchmarks below was obtained by running the `benchmark.R` script, which is installed along with the package, on two machines.  

The benchmarks here are based on the methodology used by Erik Bernhardsson's [ANN Benchmark](https://github.com/erikbern/ann-benchmarks) github.  However, `ANN Benchmark` measures the speed of querying against an index of nearest neighbors. By contrast, `largeVis` is concerned with getting neighbors for all of the nodes in a finite dataset as quickly as possible. 

The data used is the 1-million vector, 128-feature [SIFT Dataset](http://corpus-texmex.irisa.fr/), which is the test data used by `ANN Benchmark`. 

The current set of benchmarks were run on my Macbook Air M1. You can run the `benchmark.R` script to generate your own.

I welcome submissions of output from the script from other hardware. 

## Comparison With Annoy

The following chart illustrates performance as the number of trees and post-ANNOY iterations varies. 

To facilitate comparison with the ANN Benchmark charts, the Y-axis shows the number of vectors processed per second. 

```{r plotpeformance,echo=F,fig.align='center',warning=FALSE,message=FALSE}
load(system.file("extdata", "benchmark.Rda", package = "largeVis"))
results %>% 
  mutate(time = as.numeric(time), 
         facet = precision, 
         facet = ifelse(facet < 0.95, '', 'Closeup'), 
         facet = factor(facet), 
         n_iters = ordered(n_iters), 
         n_trees = ordered(n_trees)) %>%
  ggplot(aes( y = 1000000 / time, 
              x = precision, 
              group = n_trees, 
              fill = n_iters, 
              color = n_trees
              )) +
  geom_point(size = 1.5, alpha = 0.7, shape = 21) + 
  scale_y_log10(name = "Speed, log (nodes / seconds)") + 
  scale_x_continuous("Precision", 
                breaks = c(0, 0.2, 0.4, 0.6, 0.8, 0.925, 0.95, 0.975, 1.0)) +
  facet_grid(nns ~ ., scales = "free") +
  scale_fill_manual("N. iter.", values = colors_divergent_discrete(3)(3)) +
  scale_color_grey() +
 # guides(color = guide_legend(nrow=3)) +
  ggtitle(expression(
    atop("Precision-Performance tradeoff, RcppAnnoy and largeVis",
         atop(italic("(n = 1000000; Upper Right is Better)"))
         )
    ))
```

The chart shows that adding an iteration of the post-ANNOY phase of the algorithm is a more efficient way of increasing precision than increasing the number of trees.  Note that with `n. iter. = 0`, the algorithm is approximately equivalent to running `RcppAnnoy` alone. 




